{"version":3,"sources":["components/Flowchart/util.ts","components/Flowchart/Node/OperationNode.tsx","components/Flowchart/Node/StartEndNode.tsx","components/Flowchart/Node/Node.tsx","components/Flowchart/Connection/constant.ts","components/Flowchart/Connection/Connection.tsx","components/Flowchart/Flowchart.tsx","screens/App/index.tsx","serviceWorker.js","index.js"],"names":["pathing","p1","p2","startPosition","endPosition","second","penult","points","start","x","y","end","centerX","centerY","addVerticalCenterLine","third","forth","push","addHorizontalCenterLine","addHorizontalTopLine","addHorizontalBottomLine","addVerticalRightLine","addVerticalLeftLine","addSecondXPenultY","addPenultXSecondY","direction","calcDirection","indexOf","approximatelyEquals","distanceOfPoint2Point","Math","hypot","distanceOfPointToLine","point","line","k","b","abs","sqrt","n","m","getEdgeOfPoints","minX","reduce","prev","Infinity","maxX","isIntersected","p","rect","locateConnector","node","top","left","bottom","right","locateAngle","lineGenerator","d3","d","data","isSelected","borderColor","text","approvers","length","name","height","fill","strokeWidth","width","stroke","textAnchor","type","cx","cy","rx","ry","Circle","styled","props","isConnecting","G","onDoubleClick","onMouseDown","onConnectorMouseDown","position","useMemo","OperationNode","StartEndNode","Object","keys","map","key","r","event","stopPropagation","defaultConnectionColors","pass","reject","selectedConnectionColors","nodes","getNodeConnectorOffset","useCallback","nodeId","connectorPosition","filter","item","id","source","destination","colors","i","isLast","color","replace","markerEnd","undefined","markerUnits","viewBox","refX","refY","markerWidth","markerHeight","orient","SVG","forwardRef","ref","defaultNodes","defaultConnections","readonly","onEditNode","onCreateNode","onEditConnection","onCreateConnection","style","useState","internalNodes","setInternalNodes","internalConnections","setInternalConnections","useEffect","currentNodes","setCurrentNodes","currentConnections","setCurrentConnections","selectionInfo","setSelectionInfo","connectingInfo","setConnectingInfo","draggingInfo","setDraggingInfo","cursorToChartOffset","setCursorToChartOffset","handleSVGDoubleClick","nodeData","nativeEvent","offsetX","offsetY","Date","find","handleSVGMouseDown","ctrlKey","metaKey","target","tagName","handleSVGMouseMove","currentCursorToChartOffset","edge","tempCurrentNodes","forEach","some","calcIntersectedNodes","result","internalConnection","srcNodeData","destNodeData","calcIntersectedConnections","prevState","t","findIndex","delta","update","$set","moveCurrentNodes","indexes","currentNode","internalNode","tempState","index","$apply","remove","list1","currentConn","interConn","list2","currNode","flat","$splice","sort","a","interNode","handleSVGKeyDown","keyCode","document","activeElement","getElementById","handleSVGMouseUp","round","locations","prop","sourceId","sourcePosition","destinationId","newConnection","guidelines","sourceAnglePoints","sourceAnglePoint","lines","directions","destinationPoint","useImperativeHandle","getData","connections","tabIndex","onKeyDown","onMouseUp","onMouseMove","Node","tempCurrentNode","conn","Connection","fillOpacity","guideline","strokeDasharray","x1","y1","x2","y2","App","useRef","flowchartRef","visible","connectionForm","setConnectionForm","nodeForm","setNodeForm","className","disabled","onClick","alert","JSON","stringify","current","Flowchart","setConnections","setNodes","title","onCancel","onOk","labelAlign","labelCol","span","Item","label","value","onChange","Option","option","children","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.93eaefd1.chunk.js","sourcesContent":["import {\n  ConnectionData,\n  ConnectorPosition,\n  Line,\n  NodeData,\n  Point,\n} from \"./schema\";\nimport * as d3 from \"d3\";\n\nfunction pathing(\n  p1: Point,\n  p2: Point,\n  startPosition: ConnectorPosition,\n  endPosition: ConnectorPosition | null\n): [number, number][] {\n  let points: [number, number][] = [];\n  let start: [number, number] = [p1.x, p1.y];\n  let end: [number, number] = [p2.x, p2.y];\n  let centerX = start[0] + (end[0] - start[0]) / 2;\n  let centerY = start[1] + (end[1] - start[1]) / 2;\n  let second: [number, number];\n  let addVerticalCenterLine = function () {\n    let third: [number, number] = [centerX, second[1]];\n    let forth: [number, number] = [centerX, penult[1]];\n    points.push(third);\n    points.push(forth);\n  };\n  let addHorizontalCenterLine = function () {\n    let third: [number, number] = [second[0], centerY];\n    let forth: [number, number] = [penult[0], centerY];\n    points.push(third);\n    points.push(forth);\n  };\n  let addHorizontalTopLine = function () {\n    points.push([second[0], start[1] - 50]);\n    points.push([penult[0], start[1] - 50]);\n  };\n  let addHorizontalBottomLine = function () {\n    points.push([second[0], start[1] + 50]);\n    points.push([penult[0], start[1] + 50]);\n  };\n  let addVerticalRightLine = function () {\n    points.push([start[0] + 80, second[1]]);\n    points.push([start[0] + 80, penult[1]]);\n  };\n  let addVerticalLeftLine = function () {\n    points.push([start[0] - 80, second[1]]);\n    points.push([start[0] - 80, penult[1]]);\n  };\n  let addSecondXPenultY = function () {\n    points.push([second[0], penult[1]]);\n  };\n  let addPenultXSecondY = function () {\n    points.push([penult[0], second[1]]);\n  };\n  switch (startPosition) {\n    case \"left\":\n      second = [start[0] - 20, start[1]];\n      break;\n    case \"top\":\n      second = [start[0], start[1] - 20];\n      break;\n    case \"bottom\":\n      second = [start[0], start[1] + 20];\n      break;\n    default:\n      second = [start[0] + 20, start[1]];\n      break;\n  }\n  let penult: [number, number];\n  switch (endPosition) {\n    case \"right\":\n      penult = [end[0] + 20, end[1]];\n      break;\n    case \"top\":\n      penult = [end[0], end[1] - 20];\n      break;\n    case \"bottom\":\n      penult = [end[0], end[1] + 20];\n      break;\n    default:\n      penult = [end[0] - 20, end[1]];\n      break;\n  }\n  points.push(start);\n  points.push(second);\n  startPosition = startPosition || \"right\";\n  endPosition = endPosition || \"left\";\n  let direction = calcDirection(p1, p2);\n  if (direction.indexOf(\"r\") > -1) {\n    if (startPosition === \"right\" || endPosition === \"left\") {\n      if (second[0] > centerX) {\n        second[0] = centerX;\n      }\n      if (penult[0] < centerX) {\n        penult[0] = centerX;\n      }\n    }\n  }\n  if (direction.indexOf(\"d\") > -1) {\n    if (startPosition === \"bottom\" || endPosition === \"top\") {\n      if (second[1] > centerY) {\n        second[1] = centerY;\n      }\n      if (penult[1] < centerY) {\n        penult[1] = centerY;\n      }\n    }\n  }\n  if (direction.indexOf(\"l\") > -1) {\n    if (startPosition === \"left\" || endPosition === \"right\") {\n      if (second[0] < centerX) {\n        second[0] = centerX;\n      }\n      if (penult[0] > centerX) {\n        penult[0] = centerX;\n      }\n    }\n  }\n  if (direction.indexOf(\"u\") > -1) {\n    if (startPosition === \"top\" || endPosition === \"bottom\") {\n      if (second[1] < centerY) {\n        second[1] = centerY;\n      }\n      if (penult[1] > centerY) {\n        penult[1] = centerY;\n      }\n    }\n  }\n  switch (direction) {\n    case \"lu\": {\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"top\":\n          case \"right\":\n            addSecondXPenultY();\n            break;\n          default: {\n            addHorizontalCenterLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"top\":\n            addVerticalCenterLine();\n            break;\n          default: {\n            addPenultXSecondY();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"top\":\n          case \"right\":\n            addSecondXPenultY();\n            break;\n          default: {\n            addHorizontalCenterLine();\n            break;\n          }\n        }\n      } else {\n        // startPosition is left\n        switch (endPosition) {\n          case \"top\":\n          case \"right\":\n            addVerticalCenterLine();\n            break;\n          default: {\n            addPenultXSecondY();\n            break;\n          }\n        }\n      }\n      break;\n    }\n    case \"u\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"right\": {\n            break;\n          }\n          case \"top\": {\n            addSecondXPenultY();\n            break;\n          }\n          default: {\n            addHorizontalCenterLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n            addPenultXSecondY();\n            break;\n          default: {\n            addVerticalRightLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\": {\n            addPenultXSecondY();\n            break;\n          }\n          case \"right\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          case \"top\":\n            addVerticalRightLine();\n            break;\n          default: {\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n            break;\n          default: {\n            points.push([second[0], penult[1]]);\n            break;\n          }\n        }\n      }\n      break;\n    case \"ru\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\": {\n            addVerticalCenterLine();\n            break;\n          }\n          case \"top\": {\n            addSecondXPenultY();\n            break;\n          }\n          default: {\n            addPenultXSecondY();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"top\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            addPenultXSecondY();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"right\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\":\n          case \"top\":\n            addSecondXPenultY();\n            break;\n          default: {\n            addHorizontalCenterLine();\n            break;\n          }\n        }\n      }\n      break;\n    case \"l\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n          case \"top\":\n            addHorizontalTopLine();\n            break;\n          default: {\n            addHorizontalBottomLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalBottomLine();\n            break;\n          }\n          case \"right\": {\n            addSecondXPenultY();\n            break;\n          }\n          case \"top\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalTopLine();\n            break;\n          }\n          case \"right\": {\n            addSecondXPenultY();\n            break;\n          }\n          case \"top\": {\n            break;\n          }\n          default: {\n            addVerticalCenterLine();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalTopLine();\n            break;\n          }\n          case \"right\": {\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      }\n      break;\n    case \"r\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\": {\n            break;\n          }\n          case \"right\": {\n            addHorizontalTopLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\": {\n            addSecondXPenultY();\n            break;\n          }\n          case \"right\": {\n            addHorizontalBottomLine();\n            break;\n          }\n          case \"top\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\": {\n            addPenultXSecondY();\n            break;\n          }\n          case \"right\": {\n            addHorizontalTopLine();\n            break;\n          }\n          case \"top\": {\n            break;\n          }\n          default: {\n            addVerticalCenterLine();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n          case \"top\":\n            addHorizontalTopLine();\n            break;\n          default: {\n            addHorizontalBottomLine();\n            break;\n          }\n        }\n      }\n      break;\n    case \"ld\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\": {\n            addPenultXSecondY();\n            break;\n          }\n          case \"top\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n          case \"top\":\n            addPenultXSecondY();\n            break;\n          default: {\n            addVerticalCenterLine();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\":\n          case \"top\":\n            addPenultXSecondY();\n            break;\n          case \"right\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      }\n      break;\n    case \"d\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          case \"right\": {\n            addPenultXSecondY();\n            break;\n          }\n          case \"top\": {\n            addSecondXPenultY();\n            break;\n          }\n          default: {\n            addVerticalRightLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n            addPenultXSecondY();\n            break;\n          case \"top\": {\n            break;\n          }\n          default: {\n            addVerticalRightLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\": {\n            addVerticalLeftLine();\n            break;\n          }\n          default: {\n            addVerticalRightLine();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\": {\n            break;\n          }\n          case \"right\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          case \"top\": {\n            addSecondXPenultY();\n            break;\n          }\n          default: {\n            addVerticalLeftLine();\n            break;\n          }\n        }\n      }\n      break;\n    case \"rd\": {\n      if (startPosition === \"right\" && endPosition === \"left\") {\n        addVerticalCenterLine();\n      } else if (startPosition === \"right\" && endPosition === \"bottom\") {\n        addSecondXPenultY();\n      } else if (\n        (startPosition === \"right\" && endPosition === \"top\") ||\n        (startPosition === \"right\" && endPosition === \"right\")\n      ) {\n        addPenultXSecondY();\n      } else if (startPosition === \"bottom\" && endPosition === \"left\") {\n        addSecondXPenultY();\n      } else if (startPosition === \"bottom\" && endPosition === \"right\") {\n        addPenultXSecondY();\n      } else if (startPosition === \"bottom\" && endPosition === \"top\") {\n        addHorizontalCenterLine();\n      } else if (startPosition === \"bottom\" && endPosition === \"bottom\") {\n        addSecondXPenultY();\n      } else if (startPosition === \"top\" && endPosition === \"left\") {\n        addPenultXSecondY();\n      } else if (startPosition === \"top\" && endPosition === \"right\") {\n        addPenultXSecondY();\n      } else if (startPosition === \"top\" && endPosition === \"top\") {\n        addPenultXSecondY();\n      } else if (startPosition === \"top\" && endPosition === \"bottom\") {\n        addVerticalCenterLine();\n      } else if (startPosition === \"left\" && endPosition === \"left\") {\n        addSecondXPenultY();\n      } else if (startPosition === \"left\" && endPosition === \"right\") {\n        addHorizontalCenterLine();\n      } else if (startPosition === \"left\" && endPosition === \"top\") {\n        addHorizontalCenterLine();\n      } else if (startPosition === \"left\" && endPosition === \"bottom\") {\n        addSecondXPenultY();\n      }\n      break;\n    }\n  }\n  points.push(penult);\n  points.push(end);\n  return points;\n}\n\nfunction calcDirection(\n  p1: Point,\n  p2: Point\n): \"l\" | \"r\" | \"u\" | \"d\" | \"lu\" | \"ru\" | \"ld\" | \"rd\" {\n  // Use approximatelyEquals to fix the problem of css position precision\n  if (p2.x < p1.x && approximatelyEquals(p2.y, p1.y)) {\n    return \"l\";\n  }\n  if (p2.x > p1.x && approximatelyEquals(p2.y, p1.y)) {\n    return \"r\";\n  }\n  if (approximatelyEquals(p2.x, p1.x) && p2.y < p1.y) {\n    return \"u\";\n  }\n  if (approximatelyEquals(p2.x, p1.x) && p2.y > p1.y) {\n    return \"d\";\n  }\n  if (p2.x < p1.x && p2.y < p1.y) {\n    return \"lu\";\n  }\n  if (p2.x > p1.x && p2.y < p1.y) {\n    return \"ru\";\n  }\n  if (p2.x < p1.x && p2.y > p1.y) {\n    return \"ld\";\n  }\n  return \"rd\";\n}\n\nfunction distanceOfPoint2Point(p1: Point, p2: Point): number {\n  return Math.hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nfunction distanceOfPointToLine(point: Point, line: Line): number {\n  const start = line[0],\n    end = line[1];\n  const k = (end.y - start.y || 1) / (end.x - start.x || 1);\n  const b = start.y - k * start.x;\n  return Math.abs(k * point.x - point.y + b) / Math.sqrt(k * k + 1);\n}\n\nfunction between(num1: number, num2: number, num: number): boolean {\n  return (num > num1 && num < num2) || (num > num2 && num < num1);\n}\n\nfunction approximatelyEquals(n: number, m: number): boolean {\n  return Math.abs(m - n) <= 3;\n}\n\nfunction getEdgeOfPoints(points: Point[]): { start: Point; end: Point } {\n  let minX = points.reduce((prev, point) => {\n    return point.x < prev ? point.x : prev;\n  }, Infinity);\n  let maxX = points.reduce((prev, point) => {\n    return point.x > prev ? point.x : prev;\n  }, 0);\n  let minY = points.reduce((prev, point) => {\n    return point.y < prev ? point.y : prev;\n  }, Infinity);\n  let maxY = points.reduce((prev, point) => {\n    return point.y > prev ? point.y : prev;\n  }, 0);\n  return { start: { x: minX, y: minY }, end: { x: maxX, y: maxY } };\n}\n\nfunction isIntersected(\n  p: Point,\n  rect: {\n    start: Point;\n    end: Point;\n  }\n): boolean {\n  return (\n    p.x > rect.start.x &&\n    p.x < rect.end.x &&\n    p.y > rect.start.y &&\n    p.y < rect.end.y\n  );\n}\n\nfunction roundTo20(number: number): number {\n  return number < 20 ? 20 : number;\n}\nfunction locateConnector(\n  node: NodeData\n): { left: Point; right: Point; top: Point; bottom: Point } {\n  const halfWidth = 60;\n  const halfHeight = 30;\n  let top = { x: node.x + halfWidth, y: node.y };\n  let left = { x: node.x, y: node.y + halfHeight };\n  let bottom = { x: node.x + halfWidth, y: node.y + 60 };\n  let right = { x: node.x + 120, y: node.y + halfHeight };\n  return { left, right, top, bottom };\n}\n\n/**\n * Get angle positions: top-left, top-right, bottom-right, bottom-left\n * @param node\n */\nfunction locateAngle(node: NodeData): [Point, Point, Point, Point] {\n  return [\n    { x: node.x, y: node.y },\n    { x: node.x + 120, y: node.y },\n    { x: node.x + 120, y: node.y + 60 },\n    { x: node.x, y: node.y + 60 },\n  ];\n}\n\nconst lineGenerator: any = d3\n  .line()\n  .x((d) => d[0])\n  .y((d) => d[1]);\n\nfunction calcIntersectedConnections(\n  internalNodes: NodeData[],\n  internalConnections: ConnectionData[],\n  rect: { start: Point; end: Point }\n): ConnectionData[] {\n  const result: ConnectionData[] = [];\n  for (const internalConnection of internalConnections) {\n    const srcNodeData = internalNodes.find(\n      (item) => item.id === internalConnection.source.id\n    );\n    const destNodeData = internalNodes.find(\n      (item) => item.id === internalConnection.destination.id\n    );\n    const points = pathing(\n      locateConnector(srcNodeData!)[internalConnection.source.position],\n      locateConnector(destNodeData!)[internalConnection.destination.position],\n      internalConnection.source.position,\n      internalConnection.destination.position\n    );\n    if (\n      points.some((point) => isIntersected({ x: point[0], y: point[1] }, rect))\n    ) {\n      result.push(internalConnection);\n    }\n  }\n  return result;\n}\n\nfunction calcIntersectedNodes(\n  internalNodes: NodeData[],\n  edge: { start: Point; end: Point }\n): NodeData[] {\n  const tempCurrentNodes: NodeData[] = [];\n  internalNodes.forEach((item) => {\n    if (locateAngle(item).some((point) => isIntersected(point, edge))) {\n      tempCurrentNodes.push(item);\n    }\n  });\n  return tempCurrentNodes;\n}\n\nfunction createConnection(\n  sourceId: number,\n  sourcePosition: ConnectorPosition,\n  destinationId: number,\n  destinationPosition: ConnectorPosition\n): ConnectionData {\n  return {\n    source: { id: sourceId, position: sourcePosition },\n    destination: { id: destinationId, position: destinationPosition },\n    id: +new Date(),\n    type: \"pass\",\n  };\n}\n\nexport {\n  isIntersected,\n  distanceOfPointToLine,\n  distanceOfPoint2Point,\n  calcDirection,\n  getEdgeOfPoints,\n  between,\n  roundTo20,\n  pathing,\n  approximatelyEquals,\n  locateConnector,\n  locateAngle,\n  lineGenerator,\n  calcIntersectedConnections,\n  calcIntersectedNodes,\n  createConnection,\n};\n","import React from \"react\";\nimport { NodeProps } from \"./schema\";\n\nexport default function ({ data, isSelected = false }: NodeProps) {\n  const borderColor = isSelected ? \"#666666\" : \"#bbbbbb\";\n  const text =\n    !data.approvers || data.approvers.length === 0\n      ? \"No approver\"\n      : data.approvers.length > 1\n      ? `${data.approvers[0].name + \"...\"}`\n      : data.approvers[0].name;\n  return (\n    <>\n      <rect\n        x={data.x}\n        y={data.y}\n        height={20}\n        fill={\"#f1f3f4\"}\n        strokeWidth={1}\n        width={120}\n        stroke={borderColor}\n      />\n      <text x={data.x + 4} y={data.y + 15}>\n        {data.name}\n      </text>\n      <rect\n        width={120}\n        height={40}\n        fill={\"white\"}\n        x={data.x}\n        y={data.y + 20}\n        strokeWidth={1}\n        stroke={borderColor}\n      />\n      <text x={data.x + 60} y={data.y + 25 + 20} textAnchor={\"middle\"}>\n        {text}\n      </text>\n    </>\n  );\n}\n","import React from \"react\";\nimport { NodeProps } from \"./schema\";\n\nexport default function ({ data, isSelected = false }: NodeProps) {\n  const borderColor = isSelected ? \"#666666\" : \"#bbbbbb\";\n  const text = data.type === \"start\" ? \"Start\" : \"End\";\n  return (\n    <>\n      <ellipse\n        cx={data.x + 60}\n        cy={data.y + 30}\n        rx={60}\n        ry={30}\n        fill={\"white\"}\n        strokeWidth={1}\n        stroke={borderColor}\n      />\n      <text x={data.x + 60} y={data.y + 5 + 30} textAnchor={\"middle\"}>\n        {text}\n      </text>\n    </>\n  );\n}\n","import { ConnectorPosition, NodeData } from \"../schema\";\nimport OperationNode from \"./OperationNode\";\nimport StartEndNode from \"./StartEndNode\";\nimport React, { useMemo } from \"react\";\nimport { locateConnector } from \"../util\";\nimport styled from \"styled-components\";\n\nconst Circle = styled(\"circle\")<{ isConnecting: boolean }>`\n  stroke: #bbbbbb;\n  cursor: crosshair;\n  opacity: ${(props) => (props.isConnecting ? 1 : 0)};\n  fill: white;\n  stroke-width: 1px;\n\n  :hover {\n    opacity: 1;\n  }\n`;\nconst G = styled(\"g\")`\n  :hover {\n    circle {\n      opacity: 1;\n    }\n  }\n`;\n\ninterface NodeProps {\n  data: NodeData;\n  isSelected: boolean;\n  isConnecting: boolean;\n  onDoubleClick: (event: React.MouseEvent<SVGGElement, MouseEvent>) => void;\n  onMouseDown: (event: React.MouseEvent<SVGGElement, MouseEvent>) => void;\n  onConnectorMouseDown: (position: ConnectorPosition) => void;\n}\n\nexport default function ({\n  data,\n  isSelected,\n  isConnecting,\n  onDoubleClick,\n  onMouseDown,\n  onConnectorMouseDown,\n}: NodeProps) {\n  const position = useMemo(() => locateConnector(data), [data]);\n  return (\n    <>\n      <G onDoubleClick={onDoubleClick} onMouseDown={onMouseDown}>\n        {data.type !== \"start\" && data.type !== \"end\" ? (\n          <OperationNode data={data} isSelected={isSelected} />\n        ) : (\n          <StartEndNode data={data} isSelected={isSelected} />\n        )}\n        {Object.keys(position).map((key) => {\n          return (\n            <Circle\n              isConnecting={isConnecting}\n              cx={position[key as ConnectorPosition].x}\n              cy={position[key as ConnectorPosition].y}\n              r={4}\n              onMouseDown={(event) => {\n                event.stopPropagation();\n                onConnectorMouseDown(key as ConnectorPosition);\n              }}\n            />\n          );\n        })}\n      </G>\n    </>\n  );\n}\n","const defaultConnectionColors = {\n  pass: \"#52c41a\",\n  reject: \"red\",\n};\n\nconst selectedConnectionColors = {\n  pass: \"#12640a\",\n  reject: \"darkred\",\n};\nexport { defaultConnectionColors, selectedConnectionColors };\n","import {lineGenerator, locateConnector, pathing} from \"../util\";\nimport React, {useCallback, useMemo} from \"react\";\nimport {ConnectionData, ConnectorPosition, NodeData} from \"../schema\";\nimport {defaultConnectionColors, selectedConnectionColors} from \"./constant\";\n\ninterface ConnectionProps {\n  data: ConnectionData;\n  nodes: NodeData[];\n  isSelected: boolean;\n  onMouseDown: (event: React.MouseEvent<SVGPathElement, MouseEvent>) => void;\n  onDoubleClick?: (event: React.MouseEvent<SVGGElement, MouseEvent>) => void;\n}\n\nexport default function ({\n  data,\n  nodes,\n  isSelected,\n  onMouseDown,\n  onDoubleClick,\n}: ConnectionProps) {\n  const getNodeConnectorOffset = useCallback(\n    (nodeId: number, connectorPosition: ConnectorPosition) => {\n      const node = nodes.filter((item) => item.id === nodeId)[0];\n      return locateConnector(node)[connectorPosition];\n    },\n    [nodes]\n  );\n  const points = pathing(\n    getNodeConnectorOffset(data.source.id, data.source.position),\n    getNodeConnectorOffset(data.destination.id, data.destination.position),\n    data.source.position,\n    data.destination.position\n  );\n  const colors = useMemo((): { pass: string; reject: string } => {\n    return isSelected ? selectedConnectionColors : defaultConnectionColors;\n  }, [isSelected]);\n  return (\n    <g>\n      {points.map((point, i) => {\n        if (i > points.length - 2) {\n          return <></>;\n        }\n\n        let source = points[i];\n        let destination = points[i + 1];\n        const isLast = i === points.length - 2;\n        const color = colors[data.type];\n        const id = `arrow${color.replace(\"#\", \"\")}`;\n        return (\n          <>\n            <path\n              stroke={colors[data.type]}\n              strokeWidth={1}\n              fill={\"none\"}\n              d={lineGenerator([source, destination])}\n              markerEnd={isLast ? `url(#${id})` : undefined}\n            />\n            {isLast && (\n              <marker\n                id={id}\n                markerUnits={\"strokeWidth\"}\n                viewBox={\"0 0 12 12\"}\n                refX={9}\n                refY={6}\n                markerWidth={12}\n                markerHeight={12}\n                orient={\"auto\"}\n              >\n                <path d={\"M2,2 L10,6 L2,10 L6,6 L2,2\"} fill={color} />\n              </marker>\n            )}\n            <path\n              onMouseDown={onMouseDown}\n              onDoubleClick={(event) => {\n                event.stopPropagation();\n                onDoubleClick?.(event);\n              }}\n              stroke={\"transparent\"}\n              strokeWidth={5}\n              fill={\"none\"}\n              d={lineGenerator([source, destination])}\n            />\n          </>\n        );\n      })}\n    </g>\n  );\n}\n","import React, {\n  CSSProperties,\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useState,\n} from \"react\";\nimport styled from \"styled-components\";\nimport update from \"immutability-helper\";\nimport {\n  ConnectionData,\n  ConnectorPosition,\n  Line,\n  NodeData,\n  Point,\n  SelectionInfo,\n} from \"./schema\";\nimport {\n  calcDirection,\n  calcIntersectedConnections,\n  calcIntersectedNodes,\n  createConnection,\n  distanceOfPoint2Point,\n  distanceOfPointToLine,\n  getEdgeOfPoints,\n  lineGenerator,\n  locateAngle,\n  locateConnector,\n  pathing,\n} from \"./util\";\nimport Node from \"./Node/Node\";\nimport Connection from \"./Connection/Connection\";\nimport { defaultConnectionColors } from \"./Connection/constant\";\n\nconst SVG = styled(\"svg\")`\n  background-size: 20px 20px, 20px 20px, 10px 10px, 10px 10px;\n  background-image: linear-gradient(to right, #dfdfdf 1px, transparent 1px),\n    linear-gradient(to bottom, #dfdfdf 1px, transparent 1px),\n    linear-gradient(to right, #f1f1f1 1px, transparent 1px),\n    linear-gradient(to bottom, #f1f1f1 1px, transparent 1px);\n  background-position: left -1px top -1px, left -1px top -1px,\n    left -1px top -1px, left -1px top -1px;\n  height: 100%;\n  width: 100%;\n  border: 1px solid #dfdfdf;\n\n  text {\n    moz-user-select: -moz-none;\n    -moz-user-select: none;\n    -o-user-select: none;\n    -khtml-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n  }\n`;\n\ninterface FlowchartProps {\n  style?: CSSProperties;\n  defaultNodes: NodeData[];\n  defaultConnections: ConnectionData[];\n  onEditNode?: (\n    data: NodeData,\n    setNodes: React.Dispatch<React.SetStateAction<NodeData[]>>\n  ) => void;\n  onCreateNode?: (\n    data: NodeData,\n    setNodes: React.Dispatch<React.SetStateAction<NodeData[]>>\n  ) => void;\n  onEditConnection?: (\n    data: ConnectionData,\n    setConnections: React.Dispatch<React.SetStateAction<ConnectionData[]>>\n  ) => void;\n  onCreateConnection?: (\n    data: ConnectionData,\n    setConnections: React.Dispatch<React.SetStateAction<ConnectionData[]>>\n  ) => void;\n  readonly?: boolean;\n}\n\nexport default forwardRef(\n  (\n    {\n      defaultNodes,\n      defaultConnections,\n      readonly = false,\n      onEditNode,\n      onCreateNode,\n      onEditConnection,\n      onCreateConnection,\n      style,\n    }: FlowchartProps,\n    ref: any\n  ) => {\n    const [internalNodes, setInternalNodes] = useState<NodeData[]>(\n      defaultNodes\n    );\n    const [internalConnections, setInternalConnections] = useState<\n      ConnectionData[]\n    >(defaultConnections);\n    useEffect(() => {\n      setInternalConnections(defaultConnections);\n      setInternalNodes(defaultNodes);\n    }, [defaultConnections, defaultNodes]);\n    const [currentNodes, setCurrentNodes] = useState<number[]>([]);\n    const [currentConnections, setCurrentConnections] = useState<\n      ConnectionData[]\n    >([]);\n    const [selectionInfo, setSelectionInfo] = useState<SelectionInfo>();\n    const [connectingInfo, setConnectingInfo] = useState<{\n      source: NodeData;\n      sourcePosition: ConnectorPosition;\n    }>();\n    const [draggingInfo, setDraggingInfo] = useState<{\n      // todo: rename\n      target: number[];\n      delta: {\n        x: number;\n        y: number;\n      }[];\n    }>();\n    const [cursorToChartOffset, setCursorToChartOffset] = useState<Point>({\n      x: 0,\n      y: 0,\n    });\n    const handleSVGDoubleClick = useCallback(\n      (event) => {\n        let point = {\n          x: event.nativeEvent.offsetX,\n          y: event.nativeEvent.offsetY,\n          id: +new Date(),\n        };\n        let nodeData: NodeData;\n        if (!internalNodes.find((item) => item.type === \"start\")) {\n          nodeData = {\n            type: \"start\",\n            name: \"Start\",\n            ...point,\n          };\n        } else if (!internalNodes.find((item) => item.type === \"end\")) {\n          nodeData = {\n            type: \"end\",\n            name: \"End\",\n            ...point,\n          };\n        } else {\n          nodeData = {\n            ...point,\n            name: \"New\",\n            type: \"operation\",\n          };\n        }\n        return onCreateNode?.(nodeData, setInternalNodes);\n      },\n      [internalNodes, onCreateNode]\n    );\n    const handleSVGMouseDown = useCallback((event) => {\n      // @ts-ignore: can not access tagName in event.target\n      if (event.ctrlKey || event.metaKey || event.target.tagName !== \"svg\") {\n        // ignore propagation\n        return;\n      }\n\n      const point = {\n        x: event.nativeEvent.offsetX,\n        y: event.nativeEvent.offsetY,\n      };\n      setSelectionInfo({\n        start: point,\n        end: point,\n      });\n      setCurrentNodes([]);\n      setCurrentConnections([]);\n    }, []);\n    const handleSVGMouseMove = useCallback(\n      (event) => {\n        const currentCursorToChartOffset: Point = {\n          x: event.nativeEvent.offsetX,\n          y: event.nativeEvent.offsetY,\n        };\n\n        setCursorToChartOffset(currentCursorToChartOffset);\n\n        if (selectionInfo) {\n          setSelectionInfo({\n            start: selectionInfo.start,\n            end: currentCursorToChartOffset,\n          });\n\n          const edge = getEdgeOfPoints([\n            selectionInfo.start,\n            currentCursorToChartOffset,\n          ]);\n          setCurrentNodes(\n            calcIntersectedNodes(internalNodes, edge).map((item) => item.id)\n          );\n          setCurrentConnections(\n            calcIntersectedConnections(internalNodes, internalConnections, edge)\n          );\n        } else if (draggingInfo) {\n          setInternalNodes((prevState) => {\n            let result: NodeData[] = prevState;\n            for (let i = 0; i < draggingInfo.target.length; i++) {\n              let t = draggingInfo.target[i];\n              const findIndex = result.findIndex((item) => item.id === t);\n              const delta = draggingInfo.delta[i];\n              result = update(result, {\n                [findIndex]: {\n                  x: {\n                    $set: currentCursorToChartOffset.x - delta.x,\n                  },\n                  y: {\n                    $set: currentCursorToChartOffset.y - delta.y,\n                  },\n                },\n              });\n            }\n            return result;\n          });\n        }\n      },\n      [draggingInfo, internalConnections, internalNodes, selectionInfo]\n    );\n    const moveCurrentNodes = useCallback(\n      (x, y) => {\n        const indexes = currentNodes.map((currentNode) =>\n          internalNodes.findIndex(\n            (internalNode) => internalNode.id === currentNode\n          )\n        );\n        setInternalNodes((prevState) => {\n          let tempState = prevState;\n          for (const index of indexes) {\n            tempState = update(tempState, {\n              [index]: {\n                x: {\n                  $apply: (prev) => prev + x,\n                },\n                y: {\n                  $apply: (prev) => prev + y,\n                },\n              },\n            });\n          }\n          return tempState;\n        });\n      },\n      [currentNodes, internalNodes]\n    );\n    const remove = useCallback(() => {\n      if (readonly) return;\n\n      // Delete connections\n      setInternalConnections((prevState) => {\n        // Splice arguments of selected connections\n        const list1: [\n          number,\n          number\n        ][] = currentConnections.map((currentConn) => [\n          prevState.findIndex((interConn) => interConn.id === currentConn.id),\n          1,\n        ]);\n        // Splice arguments of connections of selected nodes\n        const list2: [number, number][] = currentNodes\n          .map((currNode) =>\n            internalConnections.filter(\n              (interConn) =>\n                interConn.source.id === currNode ||\n                interConn.destination.id === currNode\n            )\n          )\n          .flat()\n          .map((currentConn) => [\n            prevState.findIndex((interConn) => interConn.id === currentConn.id),\n            1,\n          ]);\n        return update(prevState, {\n          $splice: [...list1, ...list2].sort((a, b) => b[0] - a[0]),\n        });\n      });\n\n      // Delete nodes\n      setInternalNodes((prevState) =>\n        update(prevState, {\n          $splice: currentNodes\n            .map((currNode) => [\n              prevState.findIndex((interNode) => interNode.id === currNode),\n              1,\n            ])\n            .sort((a, b) => b[0] - a[0]) as [number, number][],\n        })\n      );\n    }, [currentConnections, currentNodes, internalConnections, readonly]);\n    const handleSVGKeyDown = useCallback(\n      (event) => {\n        switch (event.keyCode) {\n          case 37:\n            moveCurrentNodes(-10, 0);\n            break;\n          case 38:\n            moveCurrentNodes(0, -10);\n            break;\n          case 39:\n            moveCurrentNodes(10, 0);\n            break;\n          case 40:\n            moveCurrentNodes(0, 10);\n            break;\n          case 27:\n            setCurrentNodes([]);\n            setCurrentConnections([]);\n            break;\n          case 65:\n            if (\n              (event.ctrlKey || event.metaKey) &&\n              document.activeElement === document.getElementById(\"chart\")\n            ) {\n              setCurrentNodes([]);\n              setCurrentConnections([]);\n              setCurrentNodes(internalNodes.map((item) => item.id));\n              setCurrentConnections([...currentConnections]);\n            }\n            break;\n          case 46:\n          case 8:\n            remove();\n            break;\n          default:\n            break;\n        }\n      },\n      [currentConnections, internalNodes, moveCurrentNodes, remove]\n    );\n    const handleSVGMouseUp = useCallback(() => {\n      setSelectionInfo(undefined);\n      setConnectingInfo(undefined);\n      setDraggingInfo(undefined);\n\n      // Align dragging node\n      if (draggingInfo) {\n        setInternalNodes((prevState) => {\n          let result: NodeData[] = prevState;\n          for (const t of draggingInfo.target) {\n            result = update(result, {\n              [result.findIndex((item) => item.id === t)]: {\n                x: {\n                  $apply: (prevState) =>\n                    Math.round(Math.round(prevState) / 10) * 10,\n                },\n                y: {\n                  $apply: (prevState) =>\n                    Math.round(Math.round(prevState) / 10) * 10,\n                },\n              },\n            });\n          }\n          return result!;\n        });\n      }\n\n      // Connect nodes\n      if (!connectingInfo) {\n        return;\n      }\n      let node: NodeData | null = null;\n      let position: ConnectorPosition | null = null;\n      for (const internalNode of internalNodes) {\n        const locations = locateConnector(internalNode);\n        for (const prop in locations) {\n          const entry = locations[prop as ConnectorPosition];\n          if (distanceOfPoint2Point(entry, cursorToChartOffset) < 6) {\n            node = internalNode;\n            position = prop as ConnectorPosition;\n          }\n        }\n      }\n      if (!node || !position) {\n        return;\n      }\n      if (connectingInfo.source.id === node.id) {\n        // Node can not connect to itself\n        return;\n      }\n      const newConnection = createConnection(\n        connectingInfo.source.id,\n        connectingInfo.sourcePosition,\n        node.id,\n        position\n      );\n      onCreateConnection?.(newConnection, setInternalConnections);\n    }, [\n      connectingInfo,\n      cursorToChartOffset,\n      draggingInfo,\n      internalNodes,\n      onCreateConnection,\n    ]);\n\n    // todo: cache compute result\n    let points: [number, number][] | undefined = undefined;\n    if (connectingInfo) {\n      let endPosition: ConnectorPosition | null = null;\n      for (let internalNode of internalNodes) {\n        const locations = locateConnector(internalNode);\n        for (const prop in locations) {\n          let entry = locations[prop as ConnectorPosition];\n          if (distanceOfPoint2Point(entry, cursorToChartOffset) < 6) {\n            endPosition = prop as ConnectorPosition;\n          }\n        }\n      }\n\n      points = pathing(\n        locateConnector(connectingInfo.source)[connectingInfo.sourcePosition],\n        cursorToChartOffset!,\n        connectingInfo.sourcePosition,\n        endPosition\n      );\n    }\n    const guidelines: Line[] = [];\n    if (draggingInfo) {\n      for (const source of draggingInfo.target) {\n        const sourceAnglePoints = locateAngle(\n          internalNodes.find((item) => item.id === source)!\n        );\n        for (let i = 0; i < sourceAnglePoints.length; i++) {\n          const sourceAnglePoint = {\n            x: Math.round(Math.round(sourceAnglePoints[i].x) / 10) * 10,\n            y: Math.round(Math.round(sourceAnglePoints[i].y) / 10) * 10,\n          };\n\n          let lines: Line[];\n          let directions: (\"l\" | \"r\" | \"u\" | \"d\" | \"lu\" | \"ru\" | \"ld\" | \"rd\")[];\n          switch (i) {\n            case 0: {\n              lines = [\n                [{ x: sourceAnglePoint.x, y: 0 }, sourceAnglePoint],\n                [{ x: 0, y: sourceAnglePoint.y }, sourceAnglePoint],\n              ];\n              directions = [\"lu\", \"u\", \"l\"];\n              break;\n            }\n            case 1: {\n              lines = [\n                [{ x: sourceAnglePoint.x, y: 0 }, sourceAnglePoint],\n                // todo: replace 10000 with the width of svg\n                [{ x: 10000, y: sourceAnglePoint.y }, sourceAnglePoint],\n              ];\n              directions = [\"ru\", \"u\", \"r\"];\n              break;\n            }\n            case 2: {\n              lines = [\n                [{ x: sourceAnglePoint.x, y: 10000 }, sourceAnglePoint],\n                [{ x: 10000, y: sourceAnglePoint.y }, sourceAnglePoint],\n              ];\n              directions = [\"r\", \"rd\", \"d\"];\n              break;\n            }\n            default: {\n              lines = [\n                [{ x: sourceAnglePoint.x, y: 10000 }, sourceAnglePoint],\n                [{ x: 0, y: sourceAnglePoint.y }, sourceAnglePoint],\n              ];\n              directions = [\"l\", \"ld\", \"d\"];\n              break;\n            }\n          }\n\n          for (const destination of internalNodes.filter(\n            (internalNode) => internalNode.id !== source\n          )) {\n            let line: Line | null = null;\n            for (const destinationPoint of locateAngle(destination)) {\n              const direction = calcDirection(\n                sourceAnglePoint,\n                destinationPoint\n              );\n              if (\n                directions.indexOf(direction) > -1 &&\n                (distanceOfPointToLine(destinationPoint, lines[0]) < 5 ||\n                  distanceOfPointToLine(destinationPoint, lines[1]) < 5)\n              ) {\n                if (\n                  line === null ||\n                  distanceOfPoint2Point(destinationPoint, sourceAnglePoint) <\n                    distanceOfPoint2Point(line[0], line[1])\n                ) {\n                  line = [destinationPoint, sourceAnglePoint];\n                }\n              }\n            }\n            if (line) {\n              guidelines.push(line);\n            }\n          }\n        }\n      }\n    }\n\n    useImperativeHandle(ref, () => ({\n      getData() {\n        return {\n          nodes: internalNodes,\n          connections: internalConnections,\n        };\n      },\n    }));\n\n    return (\n      <>\n        <SVG\n          id={\"chart\"}\n          tabIndex={0}\n          onKeyDown={handleSVGKeyDown}\n          style={style}\n          onDoubleClick={handleSVGDoubleClick}\n          onMouseUp={handleSVGMouseUp}\n          onMouseDown={handleSVGMouseDown}\n          onMouseMove={handleSVGMouseMove}\n        >\n          {internalNodes?.map((node) => (\n            <Node\n              isSelected={currentNodes.some((item) => item === node.id)}\n              isConnecting={connectingInfo !== undefined}\n              data={node}\n              onDoubleClick={(event) => {\n                event.stopPropagation();\n                onEditNode?.(node, setInternalNodes);\n              }}\n              onMouseDown={(event) => {\n                if (event.ctrlKey || event.metaKey) {\n                  const findIndex = currentNodes.findIndex(\n                    (item) => item === node.id\n                  );\n                  if (findIndex === -1) {\n                    setCurrentNodes([...currentNodes, node.id]);\n                  } else {\n                    setCurrentNodes(\n                      update(currentNodes, {\n                        $splice: [[findIndex, 1]],\n                      })\n                    );\n                  }\n                } else {\n                  let tempCurrentNodes: number[] = currentNodes;\n                  if (\n                    !currentNodes.some((currentNode) => currentNode === node.id)\n                  ) {\n                    tempCurrentNodes = [node.id];\n                    setCurrentNodes(tempCurrentNodes);\n                  }\n                  setCurrentConnections([]);\n                  setDraggingInfo({\n                    target: tempCurrentNodes,\n                    delta: tempCurrentNodes.map((tempCurrentNode) => {\n                      const find = internalNodes.find(\n                        (item) => item.id === tempCurrentNode\n                      )!;\n                      return {\n                        x: cursorToChartOffset.x - find.x,\n                        y: cursorToChartOffset.y - find.y,\n                      };\n                    }),\n                  });\n                }\n              }}\n              onConnectorMouseDown={(position) => {\n                if (node.type === \"end\") {\n                  return;\n                }\n\n                setConnectingInfo({\n                  source: node,\n                  sourcePosition: position,\n                });\n              }}\n            />\n          ))}\n          {internalConnections?.map((conn) => {\n            return (\n              <Connection\n                isSelected={currentConnections.some(\n                  (item) => conn.id === item.id\n                )}\n                onDoubleClick={() =>\n                  onEditConnection?.(conn, setInternalConnections)\n                }\n                onMouseDown={(event) => {\n                  if (event.ctrlKey || event.metaKey) {\n                    const findIndex = currentConnections.findIndex(\n                      (item) => item.id === conn.id\n                    );\n                    if (findIndex === -1) {\n                      setCurrentConnections([...currentConnections, conn]);\n                    } else {\n                      setCurrentConnections(\n                        update(currentConnections, {\n                          $splice: [[findIndex, 1]],\n                        })\n                      );\n                    }\n                  } else {\n                    setCurrentNodes([]);\n                    setCurrentConnections([conn]);\n                  }\n                }}\n                data={conn}\n                nodes={internalNodes}\n              />\n            );\n          })}\n          {selectionInfo && (\n            <rect\n              stroke={\"lightblue\"}\n              fill={\"lightblue\"}\n              fillOpacity={0.8}\n              x={\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).start\n                  .x\n              }\n              y={\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).start\n                  .y\n              }\n              width={\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).end\n                  .x -\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).start\n                  .x\n              }\n              height={\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).end\n                  .y -\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).start\n                  .y\n              }\n            />\n          )}\n          {connectingInfo && (\n            <g>\n              {points!.map((point, i) => {\n                if (i > points!.length - 2) {\n                  return <></>;\n                }\n\n                let source = points![i];\n                let destination = points![i + 1];\n                const isLast = i === points!.length - 2;\n                const color = defaultConnectionColors.pass;\n                const id = `arrow${color.replace(\"#\", \"\")}`;\n                return (\n                  <>\n                    <path\n                      stroke={defaultConnectionColors.pass}\n                      strokeWidth={1}\n                      fill={\"none\"}\n                      d={lineGenerator([source, destination])}\n                      markerEnd={isLast ? `url(#${id})` : undefined}\n                    />\n                    {isLast && (\n                      <marker\n                        id={id}\n                        markerUnits={\"strokeWidth\"}\n                        viewBox={\"0 0 12 12\"}\n                        refX={9}\n                        refY={6}\n                        markerWidth={12}\n                        markerHeight={12}\n                        orient={\"auto\"}\n                      >\n                        <path d={\"M2,2 L10,6 L2,10 L6,6 L2,2\"} fill={color} />\n                      </marker>\n                    )}\n                    <path\n                      stroke={\"transparent\"}\n                      strokeWidth={5}\n                      fill={\"none\"}\n                      d={lineGenerator([source, destination])}\n                    />\n                  </>\n                );\n              })}\n            </g>\n          )}\n          {guidelines.map((guideline) => (\n            <g>\n              <line\n                strokeDasharray={\"3 3\"}\n                stroke={\"#666666\"}\n                strokeWidth={1}\n                fill={\"none\"}\n                x1={guideline[0].x}\n                y1={guideline[0].y}\n                x2={guideline[1].x}\n                y2={guideline[1].y}\n              />\n            </g>\n          ))}\n        </SVG>\n      </>\n    );\n  }\n);\n","import React, { useRef, useState } from \"react\";\nimport \"./index.css\";\nimport Flowchart from \"../../components/Flowchart/Flowchart\";\nimport {\n  ConnectionData,\n  NodeData,\n  NodeType,\n} from \"../../components/Flowchart/schema\";\nimport update from \"immutability-helper\";\nimport { Form, Input, Modal, Select } from \"antd\";\nimport \"antd/dist/antd.css\";\n\nfunction App() {\n  const [nodes, setNodes] = useState<NodeData[]>([\n    {\n      type: \"start\",\n      name: \"Start\",\n      x: 150,\n      y: 190,\n      id: 1604410569920,\n      approvers: [],\n    },\n    {\n      type: \"end\",\n      name: \"End\",\n      x: 500,\n      y: 190,\n      id: 1604410572363,\n      approvers: [],\n    },\n    {\n      x: 330,\n      y: 190,\n      id: 1604410575428,\n      name: \"New\",\n      type: \"operation\",\n      approvers: [{ name: \"Joyce\", id: \"1\" }],\n    },\n    {\n      x: 330,\n      y: 300,\n      id: 1604410591865,\n      name: \"New\",\n      type: \"operation\",\n      approvers: [],\n    },\n  ]);\n  const [connections, setConnections] = useState<ConnectionData[]>([\n    {\n      source: { id: 1604410569920, position: \"right\" },\n      destination: { id: 1604410575428, position: \"left\" },\n      id: 1604410587907,\n      type: \"pass\",\n    },\n    {\n      source: { id: 1604410575428, position: \"right\" },\n      destination: { id: 1604410572363, position: \"left\" },\n      id: 1604410590524,\n      type: \"pass\",\n    },\n    {\n      source: { id: 1604410569920, position: \"bottom\" },\n      destination: { id: 1604410591865, position: \"left\" },\n      id: 1604410596866,\n      type: \"pass\",\n    },\n    {\n      source: { id: 1604410591865, position: \"right\" },\n      destination: { id: 1604410572363, position: \"bottom\" },\n      id: 1604410599205,\n      type: \"pass\",\n    },\n  ]);\n  const setInternalNodes = useRef<\n    React.Dispatch<React.SetStateAction<NodeData[]>>\n  >();\n  const setInternalConnections = useRef<\n    React.Dispatch<React.SetStateAction<ConnectionData[]>>\n  >();\n  const flowchartRef = useRef<any>();\n  const [connectionForm, setConnectionForm] = useState<{\n    visible: boolean;\n    type: \"pass\" | \"reject\";\n    id?: number;\n  }>({ visible: false, type: \"pass\" });\n  const [nodeForm, setNodeForm] = useState<{\n    visible: boolean;\n    id?: number;\n    name: string;\n    type: NodeType;\n    approvers?: { name: string; [key: string]: any }[];\n  }>({\n    visible: false,\n    name: \"\",\n    type: \"operation\",\n  });\n\n  return (\n    <>\n      <div className=\"container\" style={{ height: 500 }}>\n        <h1 className=\"title\">Flowchart React</h1>\n        <h5 className=\"subtitle\">\n          Flowchart & Flowchart designer component for React.js.\n        </h5>\n        <div id=\"toolbar\">\n          <button disabled={true} onClick={() => {}}>\n            Add(Double-click canvas)\n          </button>\n          <button disabled={true}>Delete(Del)</button>\n          <button disabled={true}>Edit(Double-click node)</button>\n          <button\n            onClick={() =>\n              alert(JSON.stringify(flowchartRef.current.getData()))\n            }\n          >\n            Save\n          </button>\n        </div>\n        <>\n          <Flowchart\n            ref={flowchartRef}\n            onEditConnection={(data, setConnections) => {\n              setInternalConnections.current = setConnections;\n              setConnectionForm({\n                visible: true,\n                id: data.id,\n                type: data.type,\n              });\n            }}\n            onCreateConnection={(data, setConnections) => {\n              setInternalConnections.current = setConnections;\n              setConnections((prevState) => [...prevState, data]);\n            }}\n            onEditNode={(data, setNodes) => {\n              setInternalNodes.current = setNodes;\n              setNodeForm({\n                approvers: data.approvers,\n                name: data.name,\n                type: data.type,\n                visible: true,\n                id: data.id,\n              });\n            }}\n            onCreateNode={(data, setNodes) => {\n              setInternalNodes.current = setNodes;\n              setNodes((prevState) => [\n                ...prevState,\n                { ...data, approvers: [] },\n              ]);\n            }}\n            defaultNodes={nodes}\n            defaultConnections={connections}\n          />\n          <Modal\n            visible={nodeForm.visible}\n            title={\"节点\"}\n            width={400}\n            onCancel={() =>\n              setNodeForm({\n                id: undefined,\n                type: \"operation\",\n                visible: false,\n                name: \"\",\n                approvers: undefined,\n              })\n            }\n            onOk={() => {\n              setNodeForm({\n                id: undefined,\n                type: \"operation\",\n                visible: false,\n                name: \"\",\n                approvers: undefined,\n              });\n              setInternalNodes.current!((prevState) =>\n                update(prevState, {\n                  [prevState.findIndex((item) => item.id === nodeForm.id)]: {\n                    name: {\n                      $set: nodeForm.name,\n                    },\n                    type: {\n                      $set: nodeForm.type,\n                    },\n                    approvers: {\n                      $set: nodeForm.approvers,\n                    },\n                  },\n                })\n              );\n            }}\n          >\n            <Form\n              labelAlign={\"right\"}\n              labelCol={{\n                span: 4,\n              }}\n            >\n              <Form.Item label={\"名称\"}>\n                <Input\n                  value={nodeForm.name}\n                  onChange={(event) =>\n                    setNodeForm((prevState) => ({\n                      ...prevState,\n                      name: event.target.value,\n                    }))\n                  }\n                />\n              </Form.Item>\n              <Form.Item label={\"类型\"}>\n                <Select\n                  value={nodeForm.type}\n                  onChange={(event) => {\n                    setNodeForm((prevState) => ({\n                      ...prevState,\n                      type: event as NodeType,\n                    }));\n                  }}\n                >\n                  <Select.Option value={\"start\"}>开始</Select.Option>\n                  <Select.Option value={\"end\"}>结束</Select.Option>\n                  <Select.Option value={\"operation\"}>审核</Select.Option>\n                </Select>\n              </Form.Item>\n              <Form.Item label={\"审核人\"}>\n                <Select\n                  value={nodeForm.type}\n                  onChange={(event, option: any) => {\n                    setNodeForm((prevState) => ({\n                      ...prevState,\n                      approvers: [{ name: option.children, id: option.value }],\n                    }));\n                  }}\n                >\n                  <Select.Option value={\"1\"}>Joyce</Select.Option>\n                  <Select.Option value={\"2\"}>Tiramisu</Select.Option>\n                </Select>\n              </Form.Item>\n            </Form>\n          </Modal>\n          <Modal\n            visible={connectionForm.visible}\n            title={\"流转\"}\n            width={400}\n            onCancel={() =>\n              setConnectionForm({\n                id: undefined,\n                type: \"pass\",\n                visible: false,\n              })\n            }\n            onOk={() => {\n              setConnectionForm({\n                id: undefined,\n                type: \"pass\",\n                visible: false,\n              });\n              setInternalConnections.current!((prevState) =>\n                update(prevState, {\n                  [prevState.findIndex(\n                    (item) => item.id === connectionForm.id\n                  )]: {\n                    type: {\n                      $set: connectionForm.type,\n                    },\n                  },\n                })\n              );\n            }}\n          >\n            <Form>\n              <Form.Item label={\"类型\"}>\n                <Select\n                  value={connectionForm.type}\n                  onChange={(event) => {\n                    setConnectionForm((prevState) => ({\n                      ...prevState,\n                      type: event as \"pass\" | \"reject\",\n                    }));\n                  }}\n                >\n                  <Select.Option value={\"pass\"}>同意</Select.Option>\n                  <Select.Option value={\"reject\"}>驳回</Select.Option>\n                </Select>\n              </Form.Item>\n            </Form>\n          </Modal>\n        </>\n      </div>\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './screens/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}